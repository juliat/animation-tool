/* Doodle Drawing Library
 * 
* Created: 10/2012 
 * Modified: 10/02/2012
 * Author: Julia Teitelbaum 
 *  
 */

 /* wait to draw the images until they're loaded */
 _numImages = 0;
 _numLoaded = 0;
 
/*
 * Summary:
 * Doodle is the root container for all drawable elements.
 * 
 * Fields:
 * context: the drawing context for the object, generated by a canvas
 * children: An array of the top-level drawable elements in this doodle.
 * 
 */
function Doodle (context) {
    this.context = context;
    this.children = [];
}


/* Summary:
 * Draws the children of the Doodle. If a child is not visible, it does
 * not draw the child. 
 * 
 * Return:
 * None
 */
Doodle.prototype.draw = function() {
	// wait to draw the children until all child images are loaded
	if (_numImages === _numLoaded) {
		drawChildren(this);
	}
	else {
		var doodle = this;
		setTimeout(function(){doodle.draw();}, 500);
	}	
};

/* Draw the children of a parent element. */
function drawChildren(parentObject) {
	// loop over the children
	var numChildren = parentObject.children.length;
	var i;
	for (i = 0; i < numChildren; i++) {
		// check if the child is visible
		child = parentObject.children[i];
		if (child.visible === true) {
			// if so, draw
			child.draw(parentObject.context);
		}
	}
}

/* Summary:
 * Base class for all drawable objects.
 */
function Drawable (attrs) {
    var defaults = { 
        left: 0,
        top: 0,
        visible: true,
    };
    attrs = mergeWithDefault(attrs, defaults);
    // set object attributes
	this.left = attrs.left;
	this.top = attrs.top;
	this.visible = attrs.visible;
}

/*
 * Summary: Uses the passed in context object (passed in by a doodle object)
 * to draw itself.
 */
Drawable.prototype.draw = function(context) {
    console.log("ERROR: Calling unimplemented draw method on drawable object.");
};


/* Summary:
 * Base class for objects that cannot contain child objects.
 */
function Primitive(attrs) {
    var defaults = {
        lineWidth: 1,
        color: "black"
    };
    attrs = mergeWithDefault(attrs, defaults);
    Drawable.call(this, attrs);
	
    this.lineWidth = attrs.lineWidth;
    this.color = attrs.color;
}
Primitive.inheritsFrom(Drawable);

/* 
 * Inherits from: Drawable
 * 
 * Summary:
 * A Text object draws text with the given attributes. 
 *   Note: Text is always drawn up from the bottom of the object. This is because there is no simple way 
 *         to measure the height of a text string using canvas, so we explicitly define it with height.
 * 
 * Parameters:
 * attrs: An object containing values for each of the fields in the object. 
 * 		  If the attrs parameter is not specified, or if one of the fields is 
 * 		  not specified, use predefined defaults.
 * 
 * Fields (in addition to those specified by ancestors):
 * 	 content: The text string to draw.
 * 	 fill: The fill color of the text in the form of a CSS color.
 * 	 font: The font style of the text in the form of a CSS font specification.
 * 	 height: The height of your text, in pixels.
 */
function Text(attrs) {
    var defaults = {
        content: "",
        fill: "black",
        font: "12pt Helvetica",
        height: 12
    };
	// merging with defaults will have attrs (first param) override defaults (second param)
    attrs = mergeWithDefault(attrs, defaults);
    Drawable.call(this, attrs);
    
    // set attrs for text
	this.content = attrs.content;
	this.fill = attrs.fill;
	this.font = attrs.font;
	this.height = attrs.height;
}
Text.inheritsFrom(Drawable);

Text.prototype.draw = function(context) {
	// make the context match the text attributes for this object
    context.font = this.font;
	context.fillStyle = this.fill; 
	// add/draw content
	context.fillText(this.content, this.left, this.height);
};

/* 
 * Inherits from: Drawable
 * 
 * Summary:
 * A DoodleImage object draws an image.
 * 
 * Constructor Parameter:
 * attrs: An object containing values for each of the fields in the object. 
 * 		If the attrs parameter is not specified, or if one of the fields is not specified, 
 * 		use predefined defaults.
 * 
 * Fields (in addition to those specified by ancestors):
 * 	width: The width of the image. Default is -1. 
 * 			 If image width is -1, use the natural width of the image.
 * 	height: The height of the image. Default is -1. 
 * 			  If image height is -1, use the natural height of the image.
 * 	src: The location of the image (specify a path).
*/
function DoodleImage(attrs) {
    var defaults = {
        width: -1,
        height: -1,
        src: "",
    };
    attrs = mergeWithDefault(attrs, defaults);
    Drawable.call(this, attrs);
	
	this.width = attrs.width;
	this.height = attrs.height;
	this.src = attrs.src;
	
	// add to the count of images
	_numImages++;
	
	imageObj = new Image();
	imageObj.src = this.src;
	this.imageObj = imageObj;
	
	var doodleImg = this;
	
	imageObj.onload = function() {
		// once the image is loaded, add to the loaded count
		_numLoaded++;
		console.log('loaded another image');
		
		// then get the final values for the width and height of the image, setting them
		// to the natural width or height if they're undefined
		var naturalWidth = imageObj.width;
		var naturalHeight = imageObj.height;
		doodleImg.width = (doodleImg.width !== -1) ? doodleImg.width : naturalWidth;
		doodleImg.height = (doodleImg.height !== -1) ? doodleImg.height : naturalHeight;
	}
}
DoodleImage.inheritsFrom(Drawable);

/* Summary:
 * Draws the image using the specified source, with the specified width and height.
 */
DoodleImage.prototype.draw = function (context) {
    context.drawImage(this.imageObj, this.left, this.top, this.width, this.height);
};


/* 
 * Inherits from: Primitive
 * 
 * Summary:
 * Draws a single line.
 * 
 * Constructor Parameter:
 * attrs: An object containing values for each of the fields in the object. 
 * 		  If the attrs parameter is not specified, or if one of the fields is not specified, 
 * 		  use predefined defaults (defined for you).
 * 
 * Fields (in addition to those specified by ancestors):
 * 	startX: Starting x coordinate of line. Must be >=0.
 * 	startY: Starting y coordinate of line. Must be >=0.
 * 	endX: Ending x coordinate of line. Must be >=0.
 * 	endY: Ending y coordinate of line. Must be >=0.
*/
function Line(attrs) {
    var defaults = {
        startX: 0,
        startY: 0,
        endX: 0,
        endY: 0
    };
    attrs = mergeWithDefault(attrs, defaults);
    Primitive.call(this, attrs);
    
    this.startX = attrs.startX;
	this.startY = attrs.startY;
	this.endX = attrs.endX;
	this.endY = attrs.endY;
}
Line.inheritsFrom(Primitive);

/* Method Summary:
 * Draw the line.
 */
Line.prototype.draw = function(context) {
	// set styles
	context.strokeStyle = this.color;
	context.lineWidth = this.lineWidth;
	
	// draw line
	context.beginPath();
	context.moveTo(this.startX, this.startY);
	context.lineTo(this.endX, this.endY);
	context.stroke();
};

/* 
 * Inherits from: Primitive
 * 
 * Constructor Parameter:
 * attrs: An object containing values for each of the fields in the object. 
 * 		  If the attrs parameter is not specified, or if one of the fields is 
 * 		  not specified, use predefined defaults.
 * 
 * Fields (in addition to those specified by ancestors):
 * 	x: x coordinate of the top left corner of the rectangle
 * 	y: y coordinate of the top left corner of the rectangle
 * 	width: width of the rectangle
 * 	height: height of the rectangle
*/
function Rectangle(attrs) {
    var defaults = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
    };
    attrs = mergeWithDefault(attrs, defaults);
    Primitive.call(this, attrs);

	this.x = attrs.x;
	this.y = attrs.y;
	this.width = attrs.width;
	this.height = attrs.height;
}
Rectangle.inheritsFrom(Primitive);

/* Method summary:
 * Draw the rectangle as specified by x, y, width, and height 
*/
Rectangle.prototype.draw = function (context) {
	// set style
	context.fillStyle = this.color;
	context.fill();
	context.lineWidth = this.lineWidth;
	context.strokeStyle = this.color;
	
	// draw rectangle
	context.beginPath();
	context.rect(this.x, this.y, this.width, this.height);
	context.stroke();
};

/* 
 * Inherits from: Primitive
 * 
 * Constructor Parameter:
 * attrs: An object containing values for each of the fields in the object. 
 * 		  If the attrs parameter is not specified, or if one of the fields is 
 * 		  not specified, use predefined defaults.
 * 
 * Fields (in addition to those specified by ancestors):
 * 	x: x coordinate of the top left corner
 * 	y: y coordinate of the top left corner
* 	radius: the radius of the circle
*/
function Circle(attrs){
	var defaults = {
		x: 0,
		y: 0,
		radius: 100,
		semicircleDegrees: 2 * Math.PI,
	};
    attrs = mergeWithDefault(attrs, defaults);
    Primitive.call(this, attrs);

	this.x = attrs.x;
	this.y = attrs.y;
	this.radius = attrs.radius;
	this.semicircleDegrees = attrs.semicircleDegrees;
}
Circle.inheritsFrom(Primitive);

/* Method summary:
 * Draws the circle based on x and y position and radius.
 */
Circle.prototype.draw = function(context) {
	var centerX = this.x + this.radius;
	var centerY = this.y + this.radius;
	
	// set style
	context.fillStyle = this.color;
	context.lineWidth = this.lineWidth;
	context.strokeStyle = this.color;
	
	// draw circle
	context.beginPath();
	context.arc(centerX, centerY, this.radius, 0, this.semicircleDegrees, false);
	context.fill();
	context.stroke();
}

/*
 * Inherits from: Drawable
 * 
 * A container is a rectangular object that can have other drawable objects as children. 
 * When drawn, the container draws itself as well as all of its children. All children 
 * inside the container are first rotated, then translated to their (left, top) positions 
 * and drawn.
 * (note: transformations execute in reverse order, 
 *        so to implement this first do translate, then rotate
 * ). 
 * The container also clips all of its content to its bounds.
 * 
 * Constructor Parameter:
 * attrs: An object containing values for each of the fields in the object. 
 * 		  If the attrs parameter is not specified, or if one of the fields is not specified, 
 * 		  use predefined defaults.
 * 
 * Fields (in addition to those specified by ancestors):
 * 	width: The width of the container
 * 	height: The height of the container
 * 	borderWidth: How wide the container’s border is.
 * 	borderColor: Color of the border.
 * 	fill: Fill color of the container. 
 * 		  Default value is “”. If fill is not specified or “”, do not fill in the container
 * 	children: Drawable objects that are located within the container.
*/
function Container(attrs) {
    var defaults = {
        width: 100,
        height: 100,
        fill: false,
        borderColor: "black",
        borderWidth: 0,
		containerShape: "rectangle",
		radius: 100
    };
    attrs = mergeWithDefault(attrs, defaults);
    Drawable.call(this, attrs);    
	this.children = [];
    
    this.width = attrs.width;
	this.height = attrs.height;
	this.fill = attrs.fill;
	this.borderColor = attrs.borderColor;
	this.borderWidth = attrs.borderWidth;
	this.containerShape = attrs.containerShape;
	this.radius = attrs.radius;
}
Container.inheritsFrom(Drawable);

/* Method Summary: 
 * Draws itself and its children. If a child is not visible (visible property set to false), 
 * does not draw it.*/
Container.prototype.draw = function(context) {
	this.context = context;
	/*
	 * save() allows us to save the canvas context before
	 * defining the clipping region so that we can return
	 * to the default state later on
	 */
    context.save();
	
	// draw the container
	context.beginPath();

	if (this.containerShape === "rectangle") {
		context.rect(this.left, this.top, this.width, this.height);
	}
	else if (this.containerShape === "circle") {
		context.arc(this.left + this.radius, this.top + this.radius, this.radius, 0, 2 * Math.PI, false);
	}
	
	
	if (this.borderWidth > 0) {
	    context.lineWidth = this.lineWidth;
	    context.strokeStyle = this.borderColor;
		context.stroke();
	}
	if (this.fill !== false) {
		context.fillStyle = this.fill;
		context.fill();
	}
	// make container act as clipping region
	context.clip();
	
	// set all the children to draw relative to the parent
	// (setting the context top left to be the parent's top left)
	context.translate(this.left, this.top);
    drawChildren(this);
	
	/*
	 * restore() restores the canvas context to its original state
	 * before we defined the clipping region
	 */
	context.restore();
};
